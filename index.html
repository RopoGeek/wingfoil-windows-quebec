<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wingfoil Windows – Québec Area</title>
<style>
  :root{
    /* cell colors */
    --neutral:#eee;         /* missing data (grey) */
    --blank:#ffffff;        /* criteria not met (blank) */

    /* strength scale (gust, when criteria are met) */
    --g1:#e9f9e4;  /* 10–14 kn */
    --g2:#b7f3af;  /* 14–18 kn */
    --y1:#fff3b0;  /* 18–21 kn */
    --y2:#ffd36e;  /* 21–25 kn */
    --r1:#ffb3a8;  /* 25–30 kn */
    --r2:#ff8a80;  /* 30+   */

    /* chrome */
    --grid-border:#ddd;
    --text:#222;
    --muted:#666;

    /* tide stripes */
    --tide-rise:#0a6;   /* dark green for Rising */
    --tide-fall:#b00;   /* dark red for Falling */
    --tide-slack:#bbb;  /* light grey for Slack */
    --tide-unk:transparent;

    /* UI */
    --chip:#f5f5f5;
    --chip-on:#ddf3e6;
    --chip-border:#cfcfcf;
  }

  body{font-family:system-ui,Segoe UI,Arial;margin:20px;color:var(--text)}
  header{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  h1{font-size:22px;margin:0}
  .pill{border:1px solid #aaa;border-radius:999px;padding:2px 8px;font-size:12px;color:#444}
  .muted{color:var(--muted);font-size:13px}

  /* Rules block (top, bilingual) */
  .rules-block {
    margin: 16px 0 8px;
    font-size: 15px;
    line-height: 1.45;
    background: #fafafa;
    border: 1px solid #e6e6e6;
    border-radius: 10px;
    padding: 12px 14px;
  }
  .rules-block h2 { font-size: 18px; margin: 0 0 8px; }
  .rules-cols{ display:grid; grid-template-columns: 1fr; gap: 8px; }
  @media (min-width: 720px){ .rules-cols{ grid-template-columns: 1fr 1fr; } }
  .rules-block ul { margin: 0 0 6px 20px; padding: 0; }
  .rules-block li { margin-bottom: 4px; }
  .rules-note { margin: 6px 0 0; font-size: 13px; color: var(--muted); }

  .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:12px 0}
  .tabs{display:flex;gap:8px;margin:10px 0}
  .tab,.toggle{ padding:6px 10px;border:1px solid #ccc;border-radius:999px;cursor:pointer;background:#fff }
  .tab.active{background:#f3fff6;border-color:#8fd4a8;color:#0a6}
  .toggle.active{background:#eef6ff;border-color:#76a7ff;color:#0a4}

  /* Settings panel */
  .settings-wrap{
    border:1px solid var(--grid-border);
    border-radius:10px;
    padding:10px;
    margin:10px 0 14px;
    background:#fff;
  }
  .settings-grid{
    display:grid; gap:10px;
    grid-template-columns: 1fr;
  }
  @media (min-width:900px){
    .settings-grid{ grid-template-columns: 220px 1fr 220px; align-items:flex-start; }
  }
  .settings-section h3{ margin:0 0 6px; font-size:14px }
  .select, .checkboxes{ font-size:14px }
  select{ padding:6px 8px; border:1px solid #ccc; border-radius:8px; background:#fff; }
  .dir-grid{
    display:grid; grid-template-columns: repeat(8, minmax(56px,1fr)); gap:6px;
  }
  .chip{
    user-select:none;
    padding:6px 6px; border:1px solid var(--chip-border); border-radius:8px;
    text-align:center; background:var(--chip); cursor:pointer; font-size:12px;
  }
  .chip.on{ background:var(--chip-on); border-color:#6ec099; }
  .preset-row{ display:flex; gap:6px; flex-wrap:wrap; margin-top:6px }
  .preset{ font-size:12px; background:#f0f6ff; border:1px solid #bcd3ff; border-radius:999px; padding:4px 8px; cursor:pointer }

  /* Sticky info bar for tap/focus */
  .info-bar{
    position: sticky; top: 0; z-index: 5;
    display:flex; align-items:center; gap:10px;
    padding:8px 10px; border:1px solid var(--grid-border); border-radius:10px;
    background:#fffffe; box-shadow: 0 1px 0 rgba(0,0,0,0.02); font-size:14px; min-height:36px;
  }
  .info-bar .arrow{width:18px;height:18px}
  .info-dim{color:var(--muted)}

  /* Matrix */
  .matrix-wrap{overflow-x:auto;border:1px solid var(--grid-border);border-radius:10px}
  table{border-collapse:separate;border-spacing:0;width:max-content;min-width:100%}
  th,td{border-right:1px solid var(--grid-border);border-bottom:1px solid var(--grid-border)}
  th{position:sticky;top:0;background:#fafafa;font-weight:600;font-size:12px}
  th.hour{position:sticky;left:0;background:#fafafa;font-weight:500;width:44px}
  th.day{min-width:80px;text-align:center}
  /* tiny tide stripe column placed before each day */
  th.tideStripeHead{width:6px;padding:0;background:#fafafa}
  td.tideStripe{width:6px;padding:0}
  td{height:18px;width:56px;padding:0}  /* data columns */
  .cell{
    height:18px;display:flex;align-items:center;justify-content:center;
    outline:none; cursor:pointer;
  }
  .cell:focus{box-shadow: inset 0 0 0 2px #8fd4a8}
  .hour-label{padding:0 6px;font-size:12px;color:#555}
  /* arrow */
  .arrow{width:12px;height:12px;opacity:0.9}

  /* Legend color helpers (class-based to render reliably on iOS) */
  .legend{margin:6px 0 10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:13px}
  .swatch{display:inline-block; min-width:16px; width:16px; height:12px; border:1px solid #bbb; vertical-align:middle}
  .c-g1{background:var(--g1)} .c-g2{background:var(--g2)}
  .c-y1{background:var(--y1)} .c-y2{background:var(--y2)}
  .c-r1{background:var(--r1)} .c-r2{background:var(--r2)}
  .c-neutral{background:var(--neutral)} .c-blank{background:var(--blank)}
</style>

<header>
  <h1>Wingfoil Windows – Québec Area</h1>
  <span class="pill">Local time (America/Toronto)</span>
</header>

<!-- Bilingual rules at the top -->
<div class="rules-block">
  <h2>Spot Conditions / Conditions par site</h2>
  <div class="rules-cols">
    <div>
      <ul>
        <li>
          <b>Baie de Beauport</b> — default: Gust ≥10 kn, any direction<br/>
          <i>Par défaut : Rafales ≥10 nœuds, toute direction</i>
        </li>
        <li>
          <b>Ste-Anne-de-Beaupré</b> — default: SW 200–250°, <b>rising</b> tide, gust ≥10 kn<br/>
          <i>Par défaut : SW 200–250°, marée <b>montante</b>, rafales ≥10 nœuds</i>
        </li>
        <li>
          <b>St-Jean, Île d’Orléans</b> — default: NE 30–70°, <b>falling</b> tide, gust ≥10 kn<br/>
          <i>Par défaut : NE 30–70°, marée <b>descendante</b>, rafales ≥10 nœuds</i>
        </li>
        <li>
          <b>Ange-Gardien</b> — default: SW 200–250°, <b>rising</b> tide, gust ≥10 kn<br/>
          <i>Par défaut : SW 200–250°, marée <b>montante</b>, rafales ≥10 nœuds</i>
        </li>
      </ul>
    </div>
    <div>
      <p class="rules-note">
        Arrows point <b>from</b> the wind’s source (mean wind direction).<br/>
        <i>Les flèches pointent <b>depuis</b> la provenance du vent (direction moyenne).</i>
      </p>
      <p class="rules-note">
        Thin colored stripe by each day shows the tide phase (green = rising, red = falling, grey = slack).<br/>
        <i>La fine bande à côté de chaque jour indique la phase de marée (vert = montante, rouge = descendante, gris = étale).</i>
      </p>
    </div>
  </div>
</div>

<p class="muted">
  Toggle <b>Daylight (06–21)</b> vs <b>All hours (00–23)</b>. Days = columns, hours = rows.<br/>
  Use the per-spot panel to customize minimum gust, allowed directions, and tide phase. Your preferences are saved on this device.
</p>

<div class="controls">
  <div class="tabs" id="tabs"></div>
  <div class="viewtoggles">
    <button class="toggle active" id="tgl-daylight">Daylight</button>
    <button class="toggle" id="tgl-all">All hours</button>
  </div>
</div>

<!-- Per-spot settings -->
<div class="settings-wrap" id="settingsWrap">
  <div class="settings-grid">
    <div class="settings-section">
      <h3>Minimum gust (kn) / Rafale min (nœuds)</h3>
      <select id="minGustSelect"></select>
    </div>

    <div class="settings-section">
      <h3>Allowed directions / Directions permises</h3>
      <div class="dir-grid" id="dirGrid"></div>
      <div class="preset-row">
        <span class="preset" data-preset="any">Any / Toutes</span>
        <span class="preset" data-preset="sw">SW 200–250°</span>
        <span class="preset" data-preset="ne">NE 30–70°</span>
        <span class="preset" data-preset="none">Clear / Effacer</span>
      </div>
    </div>

    <div class="settings-section">
      <h3>Tide / Marée</h3>
      <div class="checkboxes">
        <label><input type="checkbox" id="tideRise"> Rising / Montante</label><br/>
        <label><input type="checkbox" id="tideFall"> Falling / Descendante</label>
      </div>
      <p class="muted" style="margin-top:6px">
        If both are off, tide is ignored. If both are on, either phase is allowed.
      </p>
    </div>
  </div>
</div>

<!-- Sticky info bar (updates on tap/click/focus) -->
<div class="info-bar" id="infoBar">
  <span class="info-dim">Tap a cell</span>
</div>

<!-- Legend with reliable color boxes -->
<div class="legend">
  <span class="swatch c-g1"></span> 10–14 kn
  <span class="swatch c-g2"></span> 14–18 kn
  <span class="swatch c-y1"></span> 18–21 kn
  <span class="swatch c-y2"></span> 21–25 kn
  <span class="swatch c-r1"></span> 25–30 kn
  <span class="swatch c-r2"></span> ≥30 kn
  &nbsp; | &nbsp;
  <span class="swatch c-neutral"></span> Missing data / Données manquantes
  <span class="swatch c-blank"></span> Criteria not met / Critères non remplis
</div>

<div id="matrices"></div>

<script>
(async function(){
  // Default view mode
  let VIEW = 'daylight'; // 'daylight' | 'all'
  const HOUR_RANGE = { daylight:[6,21], all:[0,23] };

  // Spots
  const spots = [
    {key:'beauport',     label:'Baie de Beauport'},
    {key:'ste_anne',     label:'Ste-Anne-de-Beaupré'},
    {key:'st_jean',      label:'St-Jean, Île d’Orléans'},
    {key:'ange_gardien', label:'Ange-Gardien'},
  ];

  // Build tabs
  const tabBar = document.getElementById('tabs');
  spots.forEach((s,i)=>{
    const tab = document.createElement('button');
    tab.className = 'tab' + (i===0?' active':'');
    tab.textContent = s.label;
    tab.dataset.target = s.key;
    tabBar.appendChild(tab);
  });

  // Load data
  let data;
  try{
    data = await fetch('forecast.json?v=' + Date.now(), {cache:'no-store'}).then(r=>r.json());
  }catch(e){
    document.body.insertAdjacentHTML('beforeend',
      '<p style="color:#b00">Could not load forecast.json. Run the “Update forecast” workflow once (Actions tab).</p>');
    return;
  }
  const hours = data.hours || [];
  if (!hours.length){
    document.body.insertAdjacentHTML('beforeend',
      '<p class="muted">No data yet. Run the “Update forecast” workflow, then refresh.</p>');
    return;
  }

  // Helpers
  const infoBar = document.getElementById('infoBar');
  const matrices = document.getElementById('matrices');
  const toLocal = s => new Date(s);
  const dayKey = d => d.toLocaleDateString('en-CA', { timeZone: 'America/Toronto' });
  const dayLabel = d => d.toLocaleDateString('en-CA', { weekday:'short', month:'short', day:'2-digit', timeZone:'America/Toronto' });
  const hourStr = d => d.toLocaleString('en-CA',{ hour:'2-digit', hour12:false, timeZone:'America/Toronto' });

  function degToCardinal16(deg){
    if (deg==null || isNaN(deg)) return '';
    const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
    const ix = Math.round(((deg%360)/22.5)) % 16;
    return dirs[ix];
  }
  function arrowSVG(deg, size=12){
    if (deg==null || isNaN(deg)) return '';
    const rot = (180 + Number(deg)) % 360; // show FROM
    return `<svg class="arrow" viewBox="0 0 24 24" style="transform:rotate(${rot}deg);width:${size}px;height:${size}px">
      <path d="M12 4 L8 10 H11 V20 H13 V10 H16 Z" fill="currentColor"></path>
    </svg>`;
  }

  function strengthColor(kn){
    if (kn == null || isNaN(kn)) return 'var(--neutral)';
    const v = Number(kn);
    if (v >= 30) return 'var(--r2)';
    if (v >= 25) return 'var(--r1)';
    if (v >= 21) return 'var(--y2)';
    if (v >= 18) return 'var(--y1)';
    if (v >= 14) return 'var(--g2)';
    return 'var(--g1)'; // 10–14
  }
  function tideStripeColor(state){
    const s = (state||'').toLowerCase();
    if (s==='rising')  return 'var(--tide-rise)';
    if (s==='falling') return 'var(--tide-fall)';
    if (s==='slack')   return 'var(--tide-slack)';
    return 'var(--tide-unk)'; // unknown -> transparent
  }

  // Group rows by day
  const byDayAll = new Map();
  for(const row of hours){
    const t = toLocal(row.time);
    const k = dayKey(t);
    if(!byDayAll.has(k)) byDayAll.set(k, []);
    byDayAll.get(k).push(row);
  }
  for(const arr of byDayAll.values()){
    arr.sort((a,b)=> new Date(a.time)-new Date(b.time));
  }
  const dayOrder = Array.from(byDayAll.keys()).sort((a,b)=> new Date(a)-new Date(b));

  // ---------- Per-spot settings (saved per spot in localStorage) ----------
  const MIN_KN_OPTIONS = Array.from({length:18}, (_,i)=> i+8); // 8..25 inclusive
  const SECTORS = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];

  function sectorOf(deg){
    if (deg==null || isNaN(deg)) return null;
    const i = Math.round(((deg%360)/22.5)) % 16;
    return SECTORS[i];
  }

  const defaultSettings = {
    beauport:     { min:10, dirs: new Set(SECTORS),                tides: new Set(['rising','falling']) },
    ste_anne:     { min:10, dirs: new Set(['SSW','SW','WSW']),     tides: new Set(['rising']) },
    st_jean:      { min:10, dirs: new Set(['NNE','NE','ENE']),     tides: new Set(['falling']) },
    ange_gardien: { min:10, dirs: new Set(['SSW','SW','WSW']),     tides: new Set(['rising']) },
  };

  function loadSettings(spotKey){
    const raw = localStorage.getItem('wf_settings_'+spotKey);
    if(!raw) return structuredClone(defaultSettings[spotKey]);
    try{
      const o = JSON.parse(raw);
      return {
        min: o.min ?? defaultSettings[spotKey].min,
        dirs: new Set(o.dirs ?? Array.from(defaultSettings[spotKey].dirs)),
        tides: new Set(o.tides ?? Array.from(defaultSettings[spotKey].tides)),
      };
    }catch(_){ return structuredClone(defaultSettings[spotKey]); }
  }
  function saveSettings(spotKey, s){
    localStorage.setItem('wf_settings_'+spotKey, JSON.stringify({
      min: s.min, dirs: Array.from(s.dirs), tides: Array.from(s.tides)
    }));
  }

  let currentSpot = 'beauport';
  let settings = {
    beauport:loadSettings('beauport'),
    ste_anne:loadSettings('ste_anne'),
    st_jean:loadSettings('st_jean'),
    ange_gardien:loadSettings('ange_gardien')
  };

  // Build settings panel controls
  const gustSel = document.getElementById('minGustSelect');
  MIN_KN_OPTIONS.forEach(v=>{
    const opt = document.createElement('option');
    opt.value = v; opt.textContent = v + ' kn';
    gustSel.appendChild(opt);
  });
  const dirGrid = document.getElementById('dirGrid');
  SECTORS.forEach(sec=>{
    const div = document.createElement('div');
    div.className = 'chip';
    div.textContent = sec;
    div.dataset.sec = sec;
    dirGrid.appendChild(div);
  });
  const tideRise = document.getElementById('tideRise');
  const tideFall = document.getElementById('tideFall');

  function refreshSettingsPanel(){
    const s = settings[currentSpot];
    gustSel.value = s.min;
    [...dirGrid.children].forEach(ch=>{
      ch.classList.toggle('on', s.dirs.has(ch.dataset.sec));
    });
    tideRise.checked = s.tides.has('rising');
    tideFall.checked = s.tides.has('falling');
  }

  // Interactions: directions chips
  dirGrid.addEventListener('click', (e)=>{
    const chip = e.target.closest('.chip');
    if(!chip) return;
    const s = settings[currentSpot];
    const sec = chip.dataset.sec;
    if(s.dirs.has(sec)) s.dirs.delete(sec); else s.dirs.add(sec);
    chip.classList.toggle('on');
    saveSettings(currentSpot, s);
    render(VIEW);
  });

  // Presets
  document.querySelectorAll('.preset').forEach(p=>{
    p.addEventListener('click', ()=>{
      const which = p.dataset.preset;
      const s = settings[currentSpot];
      if(which==='any'){
        s.dirs = new Set(SECTORS);
      }else if(which==='sw'){
        s.dirs = new Set(['SSW','SW','WSW']);
      }else if(which==='ne'){
        s.dirs = new Set(['NNE','NE','ENE']);
      }else if(which==='none'){
        s.dirs = new Set();
      }
      saveSettings(currentSpot, s);
      refreshSettingsPanel();
      render(VIEW);
    });
  });

  // Gust select
  gustSel.addEventListener('change', ()=>{
    const s = settings[currentSpot];
    s.min = Number(gustSel.value);
    saveSettings(currentSpot, s);
    render(VIEW);
  });

  // Tide checkboxes
  tideRise.addEventListener('change', ()=>{
    const s = settings[currentSpot];
    if(tideRise.checked) s.tides.add('rising'); else s.tides.delete('rising');
    saveSettings(currentSpot, s);
    render(VIEW);
  });
  tideFall.addEventListener('change', ()=>{
    const s = settings[currentSpot];
    if(tideFall.checked) s.tides.add('falling'); else s.tides.delete('falling');
    saveSettings(currentSpot, s);
    render(VIEW);
  });

  // ---------- Table logic ----------
  function meetsUserRules(spotKey, gust, dir_deg, tide){
    const s = settings[spotKey];
    // gust
    if (gust == null || isNaN(gust) || Number(gust) < Number(s.min)) return false;
    // direction (if none selected, treat as ANY)
    if (dir_deg != null && !isNaN(dir_deg)) {
      const sec = sectorOf(Number(dir_deg));
      if (s.dirs.size > 0 && !s.dirs.has(sec)) return false;
    } else {
      return false;
    }
    // tide filter
    const t = String(tide||'unknown').toLowerCase();
    if (s.tides.size === 0) {
      // ignoring tide
    } else {
      if (!s.tides.has(t)) return false;
    }
    return true;
  }

  // Group by day
  const byDayAll = new Map();
  for(const row of hours){
    const t = toLocal(row.time);
    const k = dayKey(t);
    if(!byDayAll.has(k)) byDayAll.set(k, []);
    byDayAll.get(k).push(row);
  }
  for(const arr of byDayAll.values()){
    arr.sort((a,b)=> new Date(a.time)-new Date(b.time));
  }
  const dayOrder = Array.from(byDayAll.keys()).sort((a,b)=> new Date(a)-new Date(b));

  function buildMatrix(spotKey, mode){
    const [HSTART, HEND] = (mode==='daylight' ? [6,21] : [0,23]);

    const container = document.createElement('div');
    container.className = 'matrix-wrap';
    const tbl = document.createElement('table');

    // Header
    const thead = document.createElement('thead');
    const htr = document.createElement('tr');

    const corner = document.createElement('th');
    corner.className = 'hour';
    corner.textContent = 'Hour';
    htr.appendChild(corner);

    // For each day: tide stripe header + day header
    dayOrder.forEach(dk=>{
      const thStripe = document.createElement('th');
      thStripe.className = 'tideStripeHead';
      htr.appendChild(thStripe);

      const th = document.createElement('th');
      th.className = 'day';
      const dt = new Date(dk + 'T00:00:00-04:00');
      th.innerHTML = `<div class="day-head"><div class="date">${dayLabel(dt)}</div></div>`;
      htr.appendChild(th);
    });
    thead.appendChild(htr);
    tbl.appendChild(thead);

    // Build map[day][hour] = row[spotKey]
    const map = {};
    dayOrder.forEach(k=>{
      map[k] = {};
      const arr = byDayAll.get(k) || [];
      arr.forEach(row=>{
        const h = hourStr(new Date(row.time));
        map[k][h] = row[spotKey] || {};
      });
    });

    const tbody = document.createElement('tbody');

    for(let hour=HSTART; hour<=HEND; hour++){
      const hrStr = hour.toString().padStart(2,'0');
      const tr = document.createElement('tr');

      // Hour header
      const th = document.createElement('th');
      th.className = 'hour';
      th.innerHTML = `<span class="hour-label">${hrStr}</span>`;
      tr.appendChild(th);

      // For each day: tide stripe + data cell
      dayOrder.forEach(dk=>{
        const obj = (map[dk] && map[dk][hrStr]) ? map[dk][hrStr] : {};
        const tideState = (obj && obj.tide) ? obj.tide : 'unknown';

        // tide stripe cell
        const tdStripe = document.createElement('td');
        tdStripe.className = 'tideStripe';
        tdStripe.style.background = tideStripeColor(tideState);
        tr.appendChild(tdStripe);

        // data cell
        const td = document.createElement('td');

        let bg;
        if (obj.wind_kn == null) {
          bg = 'var(--neutral)';           // missing data
        } else if (meetsUserRules(spotKey, obj.wind_kn, obj.dir_deg, tideState)) {
          bg = strengthColor(obj.wind_kn); // meets criteria -> color by gust strength
        } else {
          bg = 'var(--blank)';             // criteria not met -> blank
        }

        const gust = (obj.wind_kn == null ? '-' : obj.wind_kn);
        const avg  = (obj.wind_avg_kn == null ? '' : `${obj.wind_avg_kn} kn`);
        const deg  = obj.dir_deg;
        const card = deg==null ? '' : degToCardinal16(deg);

        const tip = `${dk} ${hrStr}:00 — gust ${gust} kn${avg?`, avg ${avg}`:''}${card?` (${card}${deg!=null?` ${deg}°`:''})`:''} • tide: ${tideState}`;

        td.innerHTML = `<div class="cell" title="${tip}" tabindex="0" role="button"
            data-spot="${spotKey}"
            data-day="${dk}"
            data-hour="${hrStr}"
            data-gust="${gust}"
            data-avg="${obj.wind_avg_kn==null?'':obj.wind_avg_kn}"
            data-deg="${deg==null?'':deg}"
            data-card="${card}"
            data-tide="${tideState}"
          >${deg!=null ? arrowSVG(deg) : ''}</div>`;
        td.querySelector('.cell').style.background = bg;

        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    }

    tbl.appendChild(tbody);
    container.appendChild(tbl);
    return container;
  }

  function render(mode){
    matrices.innerHTML = '';
    const views = {};
    spots.forEach((s,i)=>{
      const v = buildMatrix(s.key, mode);
      v.style.display = i===0 ? 'block':'none';
      v.id = 'view-'+s.key;
      matrices.appendChild(v);
      views[s.key] = v;
    });

    // Tab switching (also switches the *active spot* for settings & saves)
    tabBar.onclick = (e)=>{
      const btn = e.target.closest('.tab');
      if(!btn) return;
      [...tabBar.children].forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      const target = btn.dataset.target;
      Object.values(views).forEach(v=>v.style.display='none');
      views[target].style.display = 'block';
      currentSpot = target;
      refreshSettingsPanel();
      infoBar.innerHTML = '<span class="info-dim">Tap a cell</span>';
    };

    // Cell click / keyboard support — event delegation per matrix
    Object.values(views).forEach(view=>{
      view.addEventListener('click', onCellActivate);
      view.addEventListener('keydown', (ev)=>{
        if(ev.key==='Enter' || ev.key===' '){
          const el = ev.target.closest('.cell');
          if(el){ ev.preventDefault(); onCellActivate(ev); }
        }
      });
    });
  }

  // Update sticky info bar from a cell dataset
  function onCellActivate(ev){
    const cell = ev.target.closest('.cell');
    if(!cell) return;
    const dk = cell.dataset.day;
    const hr = cell.dataset.hour;
    const gust = cell.dataset.gust || '-';
    const avg  = cell.dataset.avg ? `${cell.dataset.avg} kn` : '';
    const deg  = cell.dataset.deg;
    const card = cell.dataset.card || '';
    const tide = (cell.dataset.tide || 'unknown');
    const arrow = (deg ? arrowSVG(deg,18) : '');

    infoBar.innerHTML = `
      <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
        <div><b>${dk}</b> ${hr}:00</div>
        <div>• Gust: <b>${gust} kn</b>${avg?` (avg ${avg})`:''}</div>
        <div>• Dir: <b>${card}${deg?` ${deg}°`:''}</b> ${arrow}</div>
        <div>• Tide: <b>${tide}</b></div>
      </div>`;
  }

  // Init settings UI and first render
  refreshSettingsPanel();
  render(VIEW);

  // Toggle listeners
  const btnDay = document.getElementById('tgl-daylight');
  const btnAll = document.getElementById('tgl-all');
  function setToggle(active){
    btnDay.classList.toggle('active', active==='daylight');
    btnAll.classList.toggle('active', active==='all');
  }
  btnDay.onclick = ()=>{ VIEW='daylight'; setToggle(VIEW); render(VIEW); };
  btnAll.onclick = ()=>{ VIEW='all'; setToggle(VIEW); render(VIEW); };

})();
</script>
</html>
